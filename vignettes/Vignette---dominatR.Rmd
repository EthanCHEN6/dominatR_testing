---
title: "dominatR: Tissue Dominance and Entropy Visualization"
author: "Simon & Ethan"
output: BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{dominatR: Tissue Dominance and Entropy Visualization}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r setup, include=FALSE}
library(SummarizedExperiment)
library(ggplot2)
data("airway_se")
```


# dominatR: A Package for Normalization of RNA-seq and Gene Expression Data

Introduction

The `dominatR` package provides a flexible suite of normalization methods for transcriptomics data, including CPM, TPM, RPKM, min-max scaling, and quantile normalization. It is compatible with common data structures such as `matrix`, `data.frame`, and `SummarizedExperiment`, and is designed to streamline preprocessing in bioinformatics workflows.

# Installation
You can install the development version of 'dominatR' from GitHub:
  
```{r, eval=FALSE}
# From GitHub (development version)
if (!requireNamespace("remotes", quietly = TRUE))
  install.packages("remotes")
remotes::install_github("EthanCHEN6/dominatR_testing", force = TRUE)
```


# Data: Airway Gene Expression
This dataset contains RNA-Seq counts for airway smooth muscle cells, commonly used for gene expression analysis.

## Load Data
```{r load-packages, message=FALSE, warning=FALSE}
# Load required packages
library(dominatR)
library(SummarizedExperiment)

# Load airway dataset
library(airway)
data(airway)
airway_se <- airway
```

## Data Description
The `airway` dataset is structured as a `SummarizedExperiment` object:

- **Rows** represent genes.
- **Columns** represent samples.
- **Assay** contains raw count data.

Inspect the dataset:
```{r}
airway_se
assayNames(airway_se)
dim(assay(airway_se))
head(assay(airway_se))
```
It contains raw read counts for 63,677 genes across 8 samples.


# Normalization Methods
Normalization is critical for correcting technical biases and enabling meaningful biological comparisons.

\section{Package Features}

The package contains different normalization methods:

- `cpm_normalization`
- `minmax_normalization`
- `quantile_normalization`
- `rpkm_normalization`
- `tpm_normalization`

Let's explore the usage of each normalization method on the count data set previously described.


## Min-Max Normalization
Min-Max normalization is a linear transformation technique that rescales each gene’s expression values to a specified range (typically [0, 1]). This normalization method is useful when you want to bring the data onto the same scale.

Function Purpose:

· Rescales each column to fit within a range [new_min, new_max].

· Preserves the relative structure of values within each column.

· Useful when different assays or samples have varying scales.

### Example 1: Normalize a matrix
```{r}
# Prepare input matrix
count_mat <- assay(airway)

# Apply min-max normalization
airway_minmax <- minmax_normalization(count_mat, new_min = 0, new_max = 1)

# Inspect structure
dim(airway_minmax)
summary(as.vector(airway_minmax))
head(airway_minmax[, 1:5])
```
Why Use Custom Ranges?
You can set new_min = 10 and new_max = 20 if your downstream application prefers values in a different scale:
```{r}
df_scaled <- minmax_normalization(count_mat, new_min = 10, new_max = 20)
head(df_scaled)  # All columns now range from 10 to 20
```

### Example 2: Normalize a SummarizedExperiment
```{r}
se <- airway

# Option A: Overwrite the default assay
se1 <- minmax_normalization(se)
head(assay(se1))

# Option B: Write to a new assay slot
se2 <- minmax_normalization(se, new_assay_name = "minmax_counts")
```

Example Output:
For example, suppose column SRR1039508 originally contains gene expression values between 233 and 12890. After min-max normalization with new_min = 0, new_max = 1:

233 → mapped to 0.0

12890 → mapped to 1.0

For a gene in `SRR1039508`:
- The original expression value is `679`.
- After Min-Max normalization, the expression level is rescaled to `0.0022` on a scale of [0, 1]. This implies that `679` is very close to the lower end of the range of expression values for this gene, meaning it's likely among the least expressed in the dataset for this sample.


## Quantile Normalization
Quantile normalization makes the distribution of values across all samples identical. This technique adjusts the data so that the rank distributions of the data across samples are equal.
```{r}
## Apply quantile normalization
airway_quantile <- quantile_normalization(airway_se)

## Check result
dim(assay(airway_quantile))
summary(as.vector(assay(airway_quantile)))
head(assay(airway_quantile)[1:5, 1:5])
```
Gene expression levels were converted to counts per million reads and log2 transformed.

Example Output:
For the first gene in `SRR1039508`, the normalized value is `690.875`, which places it at a higher rank relative to other samples. This suggests that after normalization, this gene shows a higher expression across all samples.


## CPM Normalization
This vignette demonstrates how to apply Counts Per Million (CPM) normalization using the cpm_normalization() function in the dominatR package. It supports matrix, data.frame, and SummarizedExperiment formats.

Function Purpose:

The cpm_normalization() function rescales raw count data such that each column sums to one million, optionally followed by a log2 transformation. This makes count data comparable across samples of different sequencing depths.

### Example 1: Normalize a data.frame
```{r}
df <- assay(airway)
# Normalize without log2-transform
df_cpm <- cpm_normalization(df, log2_transform = FALSE)
head(df_cpm[, 1:5])

# Normalize with log2-transform
df_cpm_log <- cpm_normalization(df, log2_transform = TRUE)
head(df_cpm_log[, 1:5])
```

### Example 2: Normalize a SummarizedExperiment
```{r}
library(SummarizedExperiment)

# Apply in-place normalization (overwrite assay)
se1 <- cpm_normalization(airway, log2_transform = FALSE)
head(assay(se1))

# Save to a new assay slot
se2 <- cpm_normalization(airway, log2_transform = TRUE, new_assay_name = "cpm_logged")
head(assay(se2, "cpm_logged"))

```

### Example 3: Normalize a custom assay
```{r}
new_counts <- matrix(sample(1:100000, nrow(airway) * ncol(airway), TRUE),
                     nrow = nrow(airway))
rownames(new_counts) <- rownames(airway)
colnames(new_counts) <- colnames(airway)

assay(airway, "new_raw") <- new_counts

se3 <- cpm_normalization(airway, assay_name = "new_raw", new_assay_name = "cpm_new_raw")
head(assay(se3, "cpm_new_raw"))
```

The output of cpm_normalization() depends on the input type:

· If you input a matrix or data.frame, it returns a numeric matrix where:

  · Each column sums to 1,000,000 (unless you apply log transform).
  
  · Row and column names are preserved.
  
· If you input a SummarizedExperiment, it returns the same SE object with:

  · Either the original assay overwritten, or A new assay added (if new_assay_name is specified).



Example Output:
For example, if a gene in SRR1039508 has an original expression value of 679, after CPM normalization, it might be scaled to 5.083236. This scaling reflects that, after adjusting for sequencing depth, the gene's relative expression is lower when considering the total number of reads across the sample. This normalization ensures that the gene expression values are comparable across samples with different sequencing depths.


## RPKM Normalization
Reads per kilobase per million (RPKM) normalization adjusts for both gene length and sequencing depth, making it particularly useful for RNA-Seq data. RPKM helps compare gene expression levels across genes of different lengths.
```{r}
## Calculate gene length
rowData(airway_se)$gene_length <- rowData(airway_se)$gene_seq_end - rowData(airway_se)$gene_seq_start

## Apply RPKM normalization
airway_se_rpkm <- rpkm_normalization(airway_se, gene_length, log_trans = TRUE)

## Check the result
dim(assay(airway_se_rpkm))  # Check the dimensions
summary(as.vector(assay(airway_se_rpkm)))  # Summary statistics for all values
head(assay(airway_se_rpkm)[1:5, 1:5])
```

Example Output:
For example, if a gene in SRR1039508 has an original expression value of 679, after RPKM normalization, it might be scaled to 1.96574725. This scaling reflects that, after adjusting for both gene length and sequencing depth, the gene's relative expression is normalized, making it comparable across genes of different lengths.


## TPM Normalization
Transcripts per million normalization.
```{r}
## Calculate gene_length if not provided
rowData(airway_se)$gene_length <- rowData(airway_se)$gene_seq_end - rowData(airway_se)$gene_seq_start

## Apply TPM normalization
airway_tpm <- tpm_normalization(airway_se, log2_transform = TRUE)

## Check result
dim(assay(airway_tpm))
summary(as.vector(assay(airway_tpm)))
head(assay(airway_tpm)[1:5, 1:5])
```

Example Output:x
For example, in `SRR1039508`, if the gene expression for a particular gene is normalized to `4.43 TPM`, this indicates that the gene's expression represents `4.43` transcripts per million, accounting for both gene length and sequencing depth.


# Visualization Functions

Visual representation is essential for interpreting the structure, dominance, and variability of biological features across samples or conditions.

Our package offers a collection of entropy-based visualization functions designed for different analytical perspectives:

- `plot_circle()`  
  Displays each sample's entropy and average magnitude in a polar coordinate layout.

- `plot_circle_frequency()`  
  Summarizes the density of entropy-magnitude bins using circular heat segments.

- `plot_abacus()`  
  Groups features into quantile-based dominance categories and displays them in an abacus-style panel plot.

- `plot_rope()`  
  Compares two numeric vectors using a central “rope” layout to visualize dominance asymmetry and entropy filtering.

- `plot_triangle()`  
  Visualizes three variables in a ternary layout, highlighting balance or dominance among triplets.

Let’s now explore each visualization function with real data examples.


## plot_circle: Entropy-Magnitude Circle Plot

This function visualizes high-dimensional input (e.g., gene expression matrix) using a polar layout where each point represents a sample or feature, mapped by entropy (distributional diversity) and average magnitude (expression level).

### Description:
This function is ideal for:

-  Visualizing multidimensional datasets (samples × features) in an interpretable 2D circular space.

-  Detecting samples/features with high entropy (irregularity) or high average expression.

-  Identifying mixed-behavior regions such as dense clusters or entropy-magnitude outliers.

-  Facilitating compact visualization across thousands of rows or columns.

### Using a SummarizedExperiment input

In this example, we visualize samples from the `airway_se` dataset using raw counts. Samples with entropy > 0.5 and magnitude > 500 are highlighted. One specific sample (`SRR1039512`) is marked for emphasis.

```{r}
res_circle <- plot_circle(
  x                        = airway_se,
  n                        = ncol(airway_se),
  assay_name               = "counts",
  entropyrange             = c(0.5, 1),
  magnituderange           = c(500, NA),
  variables_highlight      = "SRR1039512",
  background_alpha_polygon = 0.1,
  output_table             = TRUE
)
```



The result is a list of two objects:

- `res[[1]]`: a `ggplot2` object for visualization
- `res[[2]]`: a `data.frame` with entropy, magnitude, etc.
```{r}
res_circle[[1]]
head(res_circle[[2]])
```



### Using a matrix or data.frame input

You can also use a raw matrix or data frame, such as one extracted from the assay slot of a SummarizedExperiment object:

```{r}
df_counts <- as.data.frame(assay(airway_se))

res_df <- plot_circle(
  x              = df_counts,
  n              = ncol(df_counts),
  entropyrange   = c(0.2, 1),
  magnituderange = c(0, NA),
  output_table   = TRUE
)
```

Also, the result is a list of two objects:

- `res[[1]]`: a `ggplot2` object for visualization
- `res[[2]]`: a `data.frame` with entropy, magnitude, etc.
```{r}
res_circle[[1]]
head(res_circle[[2]])
```



### Output interpretation

The returned data frame (res[[2]]) includes:
Sample: column name (sample ID or feature name)
Entropy: entropy score across rows (per sample/feature)
Magnitude: mean expression across all rows
Highlight: whether the point was highlighted by name




## plot_circle_frequency(): Frequency-Stratified Entropy-Magnitude Visualization

This function builds upon plot_circle() by stratifying samples into frequency bins and visualizing entropy-magnitude patterns for each bin separately.
Useful when your dataset contains variables/features with different levels of occurrence or sparsity (e.g., expressed vs. non-expressed genes).

### Description

This function is ideal for:

- Identifying highly prevalent genes/features across a cohort.

- Screening for outlier or inactive variables.

- Visually comparing distributions in a compact format.


### Example 1: Using a SummarizedExperiment object


```{r}
res_freq <- plot_circle_frequency(
  x              = airway_se,
  assay_name     = "counts",
  threshold      = 100,
  top_n          = 15,
  output_table   = TRUE
)

# Visualization
res_freq[[1]]

# Metadata table
head(res_freq[[2]])
```


### Example 2: Using a matrix or data.frame input

```{r}
mat <- assay(airway_se)

res_freq2 <- plot_circle_frequency(
  x            = mat,
  threshold    = 100,
  top_n        = 15,
  output_table = TRUE
)

res_freq2[[1]]

```



### Output interpretation

Each arc segment represents:

- A variable (e.g., gene), sorted by frequency.

- Arc height indicates proportion of samples above threshold.

- Useful for ranking and filtering in QC pipelines.

The returned table includes:

- Variable: variable name (e.g., gene ID)

- Proportion: % of samples with value above threshold

- Threshold: cutoff used

- Rank: position in sorted list


## plot_abacus(): Abacus Plot of Sample/Feature Entropy Profiles



###

###

## plot_rope(): Rope Plot for Binary Feature Dominance

This function compares two numeric vectors (e.g., expression in Condition A vs. B) using a "rope-like" 1D dominance visualization. Each sample is classified by its relative dominance, optionally filtered by entropy or magnitude thresholds.

### Description
This function is ideal for:

- Comparing two groups of measurements across matched samples or features.

- Detecting dominance shifts (e.g., gene up/down regulation between two conditions).

- Filtering samples based on entropy or effect size before plotting.

## plot_triangle(): Ternary Plot for Three-Way Feature Relationships

This function visualizes three-part compositions (e.g., condition A/B/C contributions) on a ternary plot. Useful when analyzing data with three mutually exclusive categories or proportions summing to one.

### Description
This function is ideal for:

- Displaying relationships between three mutually exclusive components.

- Exploring feature allocation among three sources or pathways (e.g., tissue A/B/C).

- Identifying samples/features located at edge or center of triangular composition space.

